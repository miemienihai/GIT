<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>理解unityInputSystem</title>
      <link href="/2023/04/04/inputSystem/"/>
      <url>/2023/04/04/inputSystem/</url>
      
        <content type="html"><![CDATA[<center><u>Main</u></center><br><m1>InputSystem基础概念梳理<p> Controls是Input System中的一个重要概念，它们的作用类似于Unity中的GameObject，可以通过代码来获取、创建、修改和管理。可以使用InputSystem.GetControls()方法获取所有的Control,Control.ReadValue()方法获取Control当前的值。换而言之Control就是指向了具体的按键,例如control1代表键盘按键a</p><p> 在Unity Input System中，Action是指一组输入映射的集合，用于将多个Control映射到一个或多个操作上。Action提供了一种更高级别的输入处理方式，通过Action，可以将多个Control绑定到同一个操作上，并为操作定义一个名称、类型、默认值等属性。为什么要引出Action,我猜测这个就是new input system的优势,将具体的物理按键Control 和代表一种抽象的运动向前运动的层级分开</p><p> Input Binding就是将一个Input Control绑定到一个Input Action上，从而使得当用户按下或者释放输入设备上的某个按钮或轴时，能够触发Input Action的回调函数,当然input Binding 自然可以绑定多个input Control 到Action 上,具体的Input Binding是内部形式,我也不知道,欢迎留言</p><p> 引入Input Maps是为了方便我们区分不同的设备映射,键盘需要一套按键控制映射的Map,手柄当然也是非常稀缺的,Input Maps是一组Input Action的集合，用于将Input Actions映射到游戏中的具体操作。Device则代表了具体物理的输入设备，包括键盘、鼠标、手柄等，它拥有标识码,厂家码等信息来代表,Unity 官方跟你定义好了Control , 因此Device都包含了一组Input Control，代表了输入设备上的各种控制（如按键、轴等）</p><p><div14>Mie哥 提交于 02: 24 PM | 固定链接 | 留言 (1)</div14></p><hr></hr>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Unity </tag>
            
            <tag> InputSystem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme主题介绍</title>
      <link href="/2023/04/03/firstblog/"/>
      <url>/2023/04/03/firstblog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="css/mysteel.css" charset="utf-8"><p><m1>重构数学库</p><p> 我们引擎中使用的数学库已经修修补补很久了。期间积累了很多想法。最近在对引擎做性能优化，把一些找到的热点系统用 C/C++ 改写，顺便就重构了一下数学库，让它更好的兼顾 Lua API 和 C API 。</p><p>上一次对数学库的改进是三年前的事情了。这三年的使用，我们发现，基于一个栈的 DSL 虽然可以减轻 Lua 和 C 之间的通讯成本，但是使用起来并不方便。大部分时候，我们还是倾向更传统的接口：一次数学运算调用一次函数。而高复杂度的数学运算完全可以放在独立的 C 模块中完成。结合 ECS 系统，我们可以在 C side 集中批量处理相同但数量巨大的数学运算。</p><p>我们在很早以前就放弃了原来设计的 DSL ，只使用数学库的部分功能。趁这次重构，我打算把这些已经废弃的部分彻底删掉，并重新设计底层的数据结构，让它能更好的适应其核心特性。</p><p>我认为我们的数学库最核心的特性是：所有的数学对象，包括矩阵、向量、四元数都是不可改写的值对象，有一致的外观。我将它表达为 64bit 的 id ，这样方便 Lua (或别的语言）binding 。</p><p>做 Lua binding 时，数学对象 id 是一个 lightuserdata 而非传统库用的重量级的 userdata 。这样用起来的代价和普通的数字相比，并无明显的额外负担。</p><p>做到这一点，最难的是对象生命期管理。我假设在使用中，大部分的数学对象都是即用即弃的，一道复杂的运算过程，只有最后一个环节被传入其它模块中。而其它第三方模块（比如物理、动画、渲染）通常会有自己的解决方案，并不依赖调用者来维持数学对象（矩阵等）的生命期。</p><p>所以，我们的数学库默认是在一块固定的临时内存块上分配数学对象的储存空间的。新的实现中，这块临时内存最多是 256 页，每页 1024 个 float4 的空间，最多可以保存 64K 个矩阵或 256K 个 vector4 。临时空间在渲染帧之间清理干净；同一帧内，对象是不会删除，一直有效的。</p><p>分配临时对象使用最简单的 bump allocator ，创建一个新对象 id 只需要一次加法，所以几乎和栈上分配同样高效，故而我们不再需要考虑把数学对象放在栈上还是堆上的问题。</p><p>对于需要持久引用的对象，可以把临时对象区的数据复制到一个永久对象区。和之前的实现不同，永久对象区的对象使用了部分的引用计数，这样可以减轻多次引用的代价。</p><p>对应的 api 是 mark 和 unmark ，可以理解为，如果一个 id 你想永久引用，那么就调用 mark(id) 生成一个新的永久 id 记住，当你不用的使用再调用 unmark(id) 放弃引用。当传递引用的时候，如果接收方也想引用它，同样需要再次 mark ；而实现可以选择内部增加引用，也可以额外再生成一个副本。</p><p>因为我们把所有的 id 都视为不可改写的数学对象，所以选择引用同一块内存还是复制数据得到新的副本，对使用者来说都是等价的。</p><p>我花了三天时间做完了重构的工作，可以在 https://github.com/cloudwu/math3d 看到现在的版本。Lua 库是我们主要使用的部分，但 mathid 这个子模块可以供 C/C++ 直接调用。</p><p><div14>Mie哥 提交于 02: 24 PM | 固定链接 | 留言 (1)</div14></p><hr></hr>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> blodTest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog 第一次尝试</title>
      <link href="/2023/04/02/hello-world/"/>
      <url>/2023/04/02/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/css/fonts-zh.css" /><link rel="stylesheet" type="text/css" href="/css/mysteel.css" charset="utf-8"><center><u>Main</u></center><p><m1>不要数据库</p><p> 我们引擎中使用的数学库已经修修补补很久了。期间积累了很多想法。最近在对引擎做性能优化，把一些找到的热点系统用 C/C++ 改写，顺便就重构了一下数学库，让它更好的兼顾 Lua API 和 C API 。</p><p>上一次对数学库的改进是三年前的事情了。这三年的使用，我们发现，基于一个栈的 DSL 虽然可以减轻 Lua 和 C 之间的通讯成本，但是使用起来并不方便。大部分时候，我们还是倾向更传统的接口：一次数学运算调用一次函数。而高复杂度的数学运算完全可以放在独立的 C 模块中完成。结合 ECS 系统，我们可以在 C side 集中批量处理相同但数量巨大的数学运算。</p><p>我们在很早以前就放弃了原来设计的 DSL ，只使用数学库的部分功能。趁这次重构，我打算把这些已经废弃的部分彻底删掉，并重新设计底层的数据结构，让它能更好的适应其核心特性。</p><p>我认为我们的数学库最核心的特性是：所有的数学对象，包括矩阵、向量、四元数都是不可改写的值对象，有一致的外观。我将它表达为 64bit 的 id ，这样方便 Lua (或别的语言）binding 。</p><p>做 Lua binding 时，数学对象 id 是一个 lightuserdata 而非传统库用的重量级的 userdata 。这样用起来的代价和普通的数字相比，并无明显的额外负担。</p><p>做到这一点，最难的是对象生命期管理。我假设在使用中，大部分的数学对象都是即用即弃的，一道复杂的运算过程，只有最后一个环节被传入其它模块中。而其它第三方模块（比如物理、动画、渲染）通常会有自己的解决方案，并不依赖调用者来维持数学对象（矩阵等）的生命期。</p><p>所以，我们的数学库默认是在一块固定的临时内存块上分配数学对象的储存空间的。新的实现中，这块临时内存最多是 256 页，每页 1024 个 float4 的空间，最多可以保存 64K 个矩阵或 256K 个 vector4 。临时空间在渲染帧之间清理干净；同一帧内，对象是不会删除，一直有效的。</p><p>分配临时对象使用最简单的 bump allocator ，创建一个新对象 id 只需要一次加法，所以几乎和栈上分配同样高效，故而我们不再需要考虑把数学对象放在栈上还是堆上的问题。</p><p>对于需要持久引用的对象，可以把临时对象区的数据复制到一个永久对象区。和之前的实现不同，永久对象区的对象使用了部分的引用计数，这样可以减轻多次引用的代价。</p><p>对应的 api 是 mark 和 unmark ，可以理解为，如果一个 id 你想永久引用，那么就调用 mark(id) 生成一个新的永久 id 记住，当你不用的使用再调用 unmark(id) 放弃引用。当传递引用的时候，如果接收方也想引用它，同样需要再次 mark ；而实现可以选择内部增加引用，也可以额外再生成一个副本。</p><p>因为我们把所有的 id 都视为不可改写的数学对象，所以选择引用同一块内存还是复制数据得到新的副本，对使用者来说都是等价的。</p><p>我花了三天时间做完了重构的工作，可以在 https://github.com/cloudwu/math3d 看到现在的版本。Lua 库是我们主要使用的部分，但 mathid 这个子模块可以供 C/C++ 直接调用。</p><p><div14>Mie哥 提交于 02: 24 PM | 固定链接 | 留言 (1)</div14></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
